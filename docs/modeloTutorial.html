<!--<section>
    <div class="numeroTutorial"></div>
    <div class="titulo"></div>
    <div class="linkdotutorial"></div>
    <div class="bibliotecas"></div>
    <div class="descricao"></div>
</section>-->

<section>
    <div class="numeroTutorial">01</div>
    <div class="titulo">Hello OpenGL</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/01_hello_opengl/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGl.GLU, OpenGL.GLUT</div>
    <div class="descricao">
        No primeiro tutorial o nosso objetivo principal é exibir na tela uma aplicação gráfica que desenha na tela uma figura quadrangular. Para isso vamos utilizar as bibliotecas OpenGl.GL, OpenGl.GLU e OpenGl.GLUT tornando a nossa aplicação portável para outras
        janelas. Vamos utilizar também a biblioteca LUtil para utilizar as funções de loop para mantes nossa aplicação rodando e também para utilizar as funções de inicialização. As constantes da biblioteca SCREEN_WIDTH, SCREEN_HEIGHT E SCREEN_FPS inicializam
        largura, altura e frames respectivamente. Ainda na biblioteca LUtil usaremos as funções update() e render() para atualizar a lógica e processar a nossa aplicação, no nosso caso a aplicação não tem nada para ser atualizado então nossa função update
        ficarásem argumentos e corpo. Essas funções e constantes são extremamente importantes para criar um contexto válido para a nossa aplicação OpenGL. Vamos usar também a função glMatrixMode() que especifica qual a matriz vai ser utilizada, glLoadIdenty()
        para utilizar como auxiliar da nossa matriz. Vamos definir cor para a nossa aplicação através da função glClearColor(), o sistema utilizado para colorir é o RGB (Red, Green, Blue) com valores que variam de 0 à 255 e o argumento Alpha, após isso
        vamos usar glGetError() para informar possíveis erros da aplicação. Dentro do render() vamos limpar o buffer de cor com a função glClear(). Após limpar a tela vamos usar glBegin() para iniciar o desenho da nossa figura, essa função delimita os
        vértices de uma figura, nessa função a ordem dos parâmetros importa, pois ligara um vértice ao seu posterior. Após delimitar nossa figura, vamos envia-la para a Unidade de Processamento Gráfico(GPU), através da função glVertex() passando as coordenadas
        x , y, z... quantas dimensões você quiser utilizar. No nosso caso vamos usar apenas 2 dimensões. Após passar as coordenadas vamos enviar as nossas coordenadas e renderizar nossa figura usando a função glEnd(). Para atualizar a tela com a nossa
        figura vamos usar glSwapBuffers(), paracriar 2 buffers um para o usuário e um para memória onde vai ser atualizado e depois vai ser invertido com o outro buffer. glutInitDisplayMode() e glutInitWindowSize() irão definir um display inicial e o
        tamanho inicial da nossa janela e glutCreateWindow()criará a janela e podemos passar um nome para ela como parâmetro. Queremos agora que a nossa figura seja exibida constantemente na tela, para isso vamos chamar uma função de loop chamada glutTimerFunc()
        para executar o frame. Agora vamos criar nossa função de loop principal que chama as outras funções de loop, a função glutMainLoop() para fazer todos os eventos GLUT entratem em loop, fazendo assim nossa figura ser exibida na tela.
    </div>
</section>

<section>
    <div class="numeroTutorial">02</div>
    <div class="titulo">Matrices and Coloring Polygons</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/02_matrices_and_coloring_polygons/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGl.GLU, OpenGL.GLUT</div>
    <div class="descricao">
        No tutorial 02 vamos utilizar um sistema de coordenadas com as dimensões 640x480 e vamos também colori-lo. Primeiro, na nossa biblioteca auxiliar LUtil, vamos definir o tamanho da tela que iremos trabalhar e definir a quantidade de frames por segundo
        com as contantes SCREEN_WIDTH, SCREEN_HEIGHT E SCREEN_FPS . Vamos também iniciar as cores do desenho como a constante COLOR_MODE_CYAN = 0 E COLOR_MODE_MULTI = 1 . Ainda em LUtil vamos chamar a função glInit() e vamos fazer os processos idênticos
        do Tutorial 01 , usando as funções glMatrixMode() e glLoadIdenty() mas adicionaremos uma nova função, a glOrtho() que multiplica a matriz atual por uma matriz ortográfica (2 dimensões) usando os valores esquerdo, direito , cima , baixo, perto
        e longe como argumentos. A nossa função update() continuará sem utilidade. Na função render() vamos limpar o buffer de cor com glClear() e vamos utlizar uma matriz Model_View para aplicar mudanças na nossa figura. A diferença entre a Model_View
        e a Model_Projection é que uma controla a visualização e a outra controla a renderização. Vamos usar a função glTranslate() para mudar nossa figura do canto superior esquerdo , para o centro da tela. Após isso, vamos definir a próxima cor do vértice
        com a função glColor() usando parâmetros do sistema RGB e vamos definir a posição do vértice com glVertex(). Observe que quando enviamos um vertice o OpenGL toma como cor base a ultima cor passada. Não podemos esquecer de atualizar a tela com
        a função glutSwapBuffers(). Outra novidade é a função handleKeys() que vamos usar para verificar a tecla pressionada e realizar uma ação se tal condição for satisfeita. No nosso caso se 'q' for pressionado ele troca de Ciano para Colorido ou vice-versa.
        Também vamos usar a tecla 'e' para mudar a escala do nosso desenho , usando a função gProjectionScale, vamos mudar ela para o dobro do tamanho, depois para metade do tamanho e depois ela volta para o tamanho inicial. A função main() é exatamente
        igual a do Tutorial 01 , muda apenas a adição de glutKeyboardFunc() para o uso do teclado.
    </div>
</section>

<section>
    <div class="numeroTutorial">03</div>
    <div class="titulo">The Viewport</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/03_the_viewport/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGl.GLU, OpenGL.GLUT</div>
    <div class="descricao">
        Neste tutorial vamos utilizar o viewport para podermos trabalhar com diferentes partes da tela , essa ferramenta é muito utilizada no desenvolvimento de jogos, pode ajudar também na portabilidade do jogo para diferentes tamanhos de tela. O viewport define
        a área da tela que iremos trabalhar . Nosso código do LUtil irá receber algumas mudanças. Na função initGL() vamos adicionar uma chamada a função glViewPort() , que define qual parte da tela vamos renderizar recebendo x e y para inicio da renderização
        e largura e altura do nosso componente. Utilizando VIEWPORT_MODE_FULL estamos dizendo para o programa que vamos utilizar a tela inteira para a renderização do nosso desenho. Dentro da nossa função render() vamos usar vários tipos de viewport.
        Primeiro, após limpar o buffer de cor da tela, e mudas nosso componente para o centro da tela com glTranstale(). Agora vamos utilizar VIEWPORT_MODE_HALF_CENTER que renderiza o nosso componente para apenas a metade da tela, como estamos usando
        640x480 nosso desenho será 320x240 . Utilizando VIEWPORT_MODE_HALF_TOP vamos passar para o compilador que queremos apenas a metade superior da tela para a renderização do nosso desenho. Com VIEWPORT_MODE_QUAD podemos desenhar diversos componentes
        por toda a tela , inclusive de cores diferentes. E , por último , VIEWPORT_MODE_RADAR que nos permite criar uma versão reduzida de todo o nosso desenho e por na tela com ele completo . É muito utilizado em jogos para fazer mapas, radares. Você
        já deve ter visto no Counter-Strike Need For Speed e em outros diversos jogos. Após criar as viewport vamos utilizar a nossa ja conhecida função handleKeys() para percorer os vários viewport definidos no nosso código. O código da nossa função
        main() é idêntico ao do tutorial 02 .
    </div>
</section>

<section>
    <div class="numeroTutorial">04</div>
    <div class="titulo">Scrolling and the Matrix Stack</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/04_scrolling_and_the_matrix_stack/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGl.GLU, OpenGL.GLUT</div>
    <div class="descricao">
        No tutorial-04, nós vamos realizar transformações na matriz de modelo de exibição (modelview) para mover a área que será renderizada na tela. Em outras palavras, movimentaremos a câmera para renderizar uma área diferente. Logo no início da nossa biblioteca
        LUtil.py, nós definimos as coordenadas x e y da câmera, com "gCameraX" e "gCameraY". A função initGL() é basicamente a mesma do tutorial-03, apenas adicionamos a função glPushMatrix() para salvar a matriz de modelo de exibição na pilha. No contexto
        atual (OpenGL 2.1) nós temos a matriz de projeção e de modelo de exibição (GL_PROJECTION e GL_MODELVIEW), além de outras duas apresentadas na documentação. Cada uma dessas matrizes possui uma pilha associada a ela, você pode adicionar uma cópia
        da matriz atual à pilha, salvando-a para mais tarde. Como dito no começo do tutorial, nós iremos realizar translações na matriz de modelo de exibição, no entanto, diferente do tutorial-02, desta vez nós não iremos fazer a chamada das funções glLoadIdentity()
        e glOrtho() a cada modificação. Nós iremos empilhar uma cópia da matriz de modelo de projeção inicial movida para a posição da câmera, salvando-a para quando seja necessário fazer modificações na mesma. Aplicar transformações da câmera à matriz
        de projeção, como foi feito no tutorial-02, é considerado uma má prática visto que isto causa interferências no cálculo de iluminação e névoa. Fizemos desta forma apenas por questão de simplicidade. Obs: A pilha de matrizes não é infinita, empilhar
        muitas matrizes pode causar o retorno de GL_STACK_OVERFLOW da função glGetError(). Na função handleKeys() nós modificamos a posição da câmera quando o usuário pressiona as teclas w, a, s ou d. Já que nós mudamos a posição da câmera, alterando
        o valor de suas coordenadas, quando o usuário pressiona uma tecla, precisamos também alterar o valor padrão da matriz da câmera. Primeiro, desempilhamos a antiga matriz padrão para a matriz atual com glPopMatrix(). Então, carregamos a matriz identidade
        na matriz atual com glLoadMatrix(). E transladamos a matriz de modelo de exibição pela deslocação da câmera, feito isto, a cena será renderizada relativamente à camera. Agora, como nós desempilhamos a matriz padrão, precisamos empilhar a nossa
        nova matriz no topo da pilha com glPushMatrix() para salva-la. Na função render(), no lugar de usar glLoadIdentity() para redefinir a matriz, usaremos glPopMatrix() para carregar a matriz que acabamos de salvar com a translação da câmera. Isto
        porque nós precisamos desta matriz para o próximo frame. Então, a reempilhamos imediatamente. Agora que a matriz de modelo de exibição renderiza tudo em relação à camera, nós podemos começar a renderizar os vértices. Renderizamos uma cena que
        tem o dobro do tamanho da altura e largura da camera. Os vértices nunca deslocam sua posição, apenas a câmera. Neste tutorial, a única transformação que aplicamos foi a translação com glTranslate(). Se você quiser aumentar ou diminuir o zoom,
        pode escalar a matriz usando glScale(). Ou rotacioná-la, usando glRotate(). Todas presentes na documentação.
    </div>
</section>

<section>
    <div class="numeroTutorial">05</div>
    <div class="titulo">Texture Mapping and Pixel Manipulation</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/05_texture_mapping_and_pixel_manipulation/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGl.GLU, OpenGL.GLUT</div>
    <div class="descricao">
        Neste tutorial vamos criar a textura de um tabuleiro de xadrez e depois vamos mapea-lo. Primeiro, vamos criar a nossa biblioteca LTEXTURE e dentro dela vamos definir a nossa classe que se chamará LTexture também. Temos que criar um construtor e também
        um destrutor da nossa classe . Após isso, vamos criar os nossos métodos. Primeiro deles é o loadTextureFromPixels32() que recebe os dados da textura a ser criada e gera uma nova textura. Temos uma função para liberar da me- moria desalocando os
        dados da textura. Dentro da nossa função render() vamos posicionar a nossa textura e mapea-lo e vamos por métodos de consulta da nossa classe como getTextureId(), textureWidth() e textureHeight() , para passar o identificador , largura e altura
        da nossa textura. Antes de começar a carregar os dados, temos que ter certeza que não está com lixo a textura, para depois atribuir as dimensões. Definimos a função glGenTextures() para gerar um identificador para a nossa textura. Com a a função
        glTexImage2D() vamos passar todos o argumentos para o nosso gerador de textura como: tipo, formato dos pixels com a textura armazenada, largura, altura, formato dos dados, largura da borda, e o endereço dos pixels que você está passando. Com a
        função glTexParameter() vamos definir de que modo a textura será exibida. Na nossa função render() vamos verificar se existe uma textura a ser criada, definir a posição dela na tela e passar os dados para cria-la. Agora vamos chamar a função glTexCoord()
        para passar uma textura á um vértice, de forma parecida de como passavamos uma cor a um vértice nos tutoriais anteriores. As texturar não trabalham como coordenas x, y, z e sim com eixos, o horizontal e o vertical e esses eixos variam de 0 à 1,
        mesmo que a quantidade de texturas/pixels seja superior a 1. Dentro de glInit() vamos adicionar a função loadMedia() para carregar os pixels da textura e glEnable() para habilitar a textu- rização em 2D. Vamos passar 128x128 para loadMedia() para
        o tamanho do nosso tabuleiro. Para colorir vamos por uma verificação, se o quinto bit de x e y são diferentes vamos passar branco, senão, passaremos vermelho (sempre com RGB). Por fim vamos rendezirar o tabuleiro no centro da tela.
    </div>
</section>

<section>
    <div class="numeroTutorial">06</div>
    <div class="titulo">Loading a Texture</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/06_loading_a_texture/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL</div>
    <div class="descricao">
        No tutorial-06, faremos o mesmo que o tutorial-05. Mas, desta vez carregaremos a imagem à partir de um arquivo. Visto isto, é importante que o arquivo a ser carregado esteja em uma pasta visível pelo python, de preferência na mesma em que se encontra
        o arquivo "main.py". Em "LTexture.py" nós iremos importar a classe "Image" e o método "open" da biblioteca PIL. loadTextureFromFile() é a nossa nova função para carregar texturas a partir de um arquivo, que recebe uma string com o caminho do arquivo
        como argumento. Logo no começo da funçao, temos a nossa flag de textura carregada. Nas próximas linhas, nós carregamos nosso arquivo com a função open(), e convertemos os dados dos pixels para o padrão RGBA com o método de classe tobytes(). Agora,
        basta passar as informações para a função loadTextureFromPixels32(), apresentada no tutorial anterior, para gerar as texturas. Os índices 0 e 1 do vetor da imagem representam a largura e altura, respectivamente. Após carregar a textura, é uma
        boa prática fechar o arquivo com close(). Na nossa biblioteca LUtil, habilitaremos o uso de texturas com glEnable() na função initGL(). E faremos a chamada da função loadTextureFromFile() para carregar nossa imagem. Tenha certeza de que o arquivo
        "opengl.png" se encontre na mesma pasta que os arquivos python. Por fim, na função render(), faremos o mesmo que foi feito no tutorial-05.
    </div>
</section>

<section>
    <div class="numeroTutorial">07</div>
    <div class="titulo">Clipping Textures</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/07_clipping_textures/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL</div>
    <div class="descricao">
        Neste tutorial vamos mapear apenas partes de uma textura para renderizar imagens em folhas de sprite. Folhas de sprite são usadas, principalmente, para animações exibindo uma sequencia de frames de imagens. Na bilioteca LFRECT vamos definimos em que parte
        da imagem vamos trabalhar. Na biblioteca LTEXTURE, vamos definir a área da textura que iremos utilizar ( podemos passar NULL para trabalhar como ele completo). Depois vamos definir as coordenadas de textura para aplicar no nosso vértice, temos
        sempre que calcular isso, pois não sa- bemos se vamos trabalhar com a imagem completa ou parte dela, para isso temos variaveis para calcular as coordenadas que vamos usar. Para calcular a textura temos que converter para 0/1. Ex:(Em uma imagem
        de 256 p , se eu quero a matede tenho que passar 0,5 e não 128 tanto para largura quanto para altura ). Com essas informaçoes podemos renderizar a nossa folha de sprite. Em LUTIL declaramos a nossa folha de sprite e criamos um vetor de retangulos.
        Na função loadMedia() definimos os retangulos e carregamos as texturas. E na função render() renderizamos os sprites de cada array em cada canto da tela da nossa imagem.
    </div>
</section>

<section>
    <div class="numeroTutorial">08</div>
    <div class="titulo">Non-Power-of-Two Textures</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/08_non_power_of_2_textures/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL</div>
    <div class="descricao">
        No tutorial-08, nós vamos renderizar uma imagem de 520x235 pixels e preenche-la numa textura de 1024x256. A forma como nós vamos renderizar uma textura que não é potência de dois (520x120) é tornar a imagem maior, preenchendo-a com pixels (512x128), e
        então cortar a parte da textura com a imagem real nela. Para fazer isto nossa função loadTexturefromPixels32() sofreu modificações, pois nós precisamos saber o tamanho da imagem original e o tamanho da textura preenchida. Por isso, adicionamos
        variáveis à classe LTexture para armazenar as dimensões tanto da imagem quanto da textura. Há também a adição da função powerOfTwo(), que usaremos para calcular o quanto será preciso redimensionar a textura. Por exemplo, se lhe dermos o argumento
        60, ela retornará 64. Em LTexture.py, importaremos o arquivo LFRect, que importa a biblioteca PIL, para usar as funções de abertura de imagem. E em nosso construtor, inicializaremos as dimensões da textura e imagem. Em loadTextureFromFile() faremos
        o carregamento e conversão da imagem como de costume. Porém, desta vez devemos ter certeza de pegar a largura e altura da imagem original. Após carregar a imagem, usaremos a função powerOfTwo() para calcular as novas dimensões da imagem para que
        ela seja potência de dois. E então verificamos se as novas dimensões e as dimensões originais não são iguais. Já que se a imagem carregada já tenha dimensões em potência de dois não faz sentido redimensioná-la. Caso a imagem precise ser redimensionada,
        definiremos sua origem como sendo o canto superior-esquerdo para que quando a imagem seja preenchida os pixels sejam adicionados na parte inferior/direita. Para preencher a imagem nós esticamos o canvas para as dimensões da textura. Com a nossa
        imagem pronta, nós a enviamos para a função loadTextureFromPixels32(). O que faremos aqui é basicamente o mesmo, com a diferença de que agora nós definimos as dimensões tanto da imagem quanto da textura. Na função render(), definiremos as coordenadas
        da textura como sendo a proporção entre as dimensões da imagem original e da textura. Isto para que a parte que foi preenchida seja cortada da renderização. Nosso destrutor é basicamente o mesmo, com adição de que ele agora retorna as dimensões
        para 0. Preencher uma imagem de 520x235 para uma textura de dimensões 1024x256 consome muitos pixels. Por este motivo, é uma boa prática colocar várias imagens em uma textura para usar a memória da GPU da forma mais eficiente o possível.
    </div>
</section>

<section>
    <div class="numeroTutorial">09</div>
    <div class="titulo">Updating Textures</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/09_updating_textures/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL</div>
    <div class="descricao">
        Neste tutorial nos vamos criar um circulo com seu background preto e adicionar listras na sua diagonal. A nossa biblioteca LTexture terá a adição de uma nova variável, se chamará mPixels que vai armazenar os dados dos pixels da textura que iremos manipular.
        Temos também, ainda em LTexture a função lock() que obtém os pixels da textura para operarmos com ele,e a função unlock() que envia os dados depois de operados para a textura. A função getPixelData() retorna para nós um apontador para o vetor
        de pixels e as funções getPixel32() e setPixel32() enviam e recebem respectivamente pixels individuais da nossa textura. Agora, antes de chamarmos nossa função FreeTexture(), temos que verificar se existe algum pixel no nosso vetor para ser liberado.
        Para usar a função lock() temos que verificar se ela já não esta manipulando alguma textura e se os pixels da nossa textura existem. Após essa verificação vamos alocar memória para nossos dados que serão copiados. Após isso nós vamos associar
        os dados recebidos com a função glTexImage() e depois vamos desvincular essa textura. Após terminar as nossas manipulações nós vamos enviar de volta os pixels da nossa textura, para isso, vamos utilizar a função glTexSubImage2D() que especifica
        uma textura bidimensional e passa a uma textura destino e depois vamos atualizar nossa textura. Uma coisa importante a salientar é que nossos pixels de textura ficam armazenados em uma matriz unidimensional, ou seja, em um vetor, assim, para obter
        uma coor- denada 2D você tem que transformar em um índice 1D. Dentro de LUtil nós vamos carregar nossa textura e usar lock() para obter os pixels e vamos bloquea-lo para podermos modifica- los. Vamos criar a nossa cor preta para passar aos pixels,
        depois vamos percorrer todos os pixels, se algum deles for o nosso alvo, nós vamos modifica-lo para um preto transparente. Agora vamos percorrer todas as linhas e colunas e vamos mudar algumas delas para colorir nossa diagonal. Depois disso usamos
        unlock() para desbloquear a textura e atualizamos a mesma. E, dentro de render(), vamos processar a nossa figura.
    </div>
</section>

<section>
    <div class="numeroTutorial">10</div>
    <div class="titulo">Color Keying and Blending</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/10_color_keying_and_blending/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL</div>
    <div class="descricao">
        Neste tutorial vamos transformar a borda branco, em uma borda transparente e a imagem central será totalmente cinza. Em LTexture vamos ter 3 novas funções para este tutorial. A primeira delas é loadPixelsFromFile() que carrega as os pixels da textura
        que iremos utilizar. Usaremos também loadTextureFromPixels32() que cria uma textura através dos seus pixels e, finalmente, loadTextureFromFileWithColorKey() que usa as funções loadPixelsFromFile() e loadTextureFromPixels32() para carregar uma
        cor de textura com uma chave, ela recebe o caminho do arquivo e os componentes RGBA da cor a ser tornada transparente. No início de nossa função loadPixelsFromFile() nós vamos liberar qualquer dado de textura que possa existir. Outra diferença
        na nossa função é que não vamos precisar criar uma nova textura do zero, nós vamos alocar memória para receber os dados copiados através da função memcpy() que recebe o destino dos dados, a origem dos a serem copiados e o tamanho dos dados, no
        nosso caso são 4 bytes por pixel, então vamos passar 4 como terceiro argumento. Depois disso vamos sobrecarregar a função loadTextureFromPixels32() usando pixels-membro para criar a nossa textura. Após isso vamos fazer o chaveamento de cores,
        vamos percorrer os nossos pixels e se encontrarmos valores iguais RGB ou RGBA e vamos criar uma textura a partir desses pixels. Agora, dentro de LUtil, precisamos habilitar uma possível mistura de cores, para isso, vamos usar a função glEnable().
        Depois vamos desativar a verificação de profundidade com a função glDisable(), pois isso é utilzado apenas em aplicativos 3D ( que não é o nosso caso neste tutorial). Por fim, vamos criar nossa mistura cm a função glBlendFunc(), primeiro argumento
        que vamos passar é como os seus pixels de origem serão considerados ( ele irá verificar se o poligono que vc está criando existe), e o segundo são os pixels de destino, vamos passar 1 como destino, pois essa função utiliza 0 à 1 como escala e
        a origem será alfa. Agora o nosso circulo terá borda transparente. Após todos esses passos, vamos renderizar nossa figura, mas antes disso vamos fazer uma chamada a glColor4f() para passar 50% como alfa global.
    </div>
</section>

<section>
    <div class="numeroTutorial">11</div>
    <div class="titulo">Stretching and Filters</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/11_stretching_and_filters/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL</div>
    <div class="descricao">
        Neste tutorial nós vamos definir quadrados de tamanhos diferentes para esticar a nossa textura e usaremos filtros para controlar como ficará a textura quando esticada. A função render() agora tem um argumento adicional: Um retângulo, para definir o quanto
        a textura será esticada, que terá valor padrão NULL para o caso de não desejarmos esticar a textura. As coordenadas da nossa textura na função render() funcionam do mesmo jeito que antes. O que muda é que iremos passar coordenadas diferentes para
        os vértices. Quando a nossa função possuir um retangulo de esticamento, as dimensões do nosso quadrado serão iguais ao tamanho do retângulo. Então, quando nosso quadrado com textura for renderizado, a textura será esticada para preencher o novo
        tamanho do quadrado. Declararemos algumas variáveis globais no topo da biblioteca LUtil.py. "gStretchedTexture" é a textura que nós vamos carregar, de 160x120 pixels. "gStretchRect" é o retângulo que usaremos para esticar a textura para o tamanho
        da tela. "gFiltering" será responsável por controlar como a textura será filtrada quando renderizada. A melhor forma de explicar como o filtro funciona é através de demonstração. Faremos isso com a nossa função handleKeys(). Na função loadMedia()
        nós carregamos a nossa textura e na função render() nós a esticamos para o tamanho da tela. Quando o usuário pressiona a tecla 'q', nós ativamos e mudamos o filtro da nossa textura. Isto é possíve mesmo que estejamos fora da classe LTexture, contanto
        que tenhamos a ID da textura que desejamos realizar as operações. As funções utilizadas para tal devem lhe parecer familiares, pois já foram usadas na função que carrega a textura. "GL_TEXTURE_MAG_FILTER" controla como a textura é filtrada quando
        esticada. O valor padrão que colocamos quando carregamos a textura é "GL_LINEAR". Isto significa que a nossa textura "mistura" os pixels ao ser esticada. Quando mudado para "GL_NEAREST", o opengl apenas pega o valor texel mais próximo, o que resulta
        numa imagem mais granulada. Vale notar que "GL_TEXTURE_MIN_FILTER" controla o filtro da textura quando ela é comprimida para um tamanho menor. Os valores dos dois não precisam ser iguais caso você queira aplicar filtros diferentes em situações
        diferentes.
    </div>
</section>

<section>
    <div class="numeroTutorial">12</div>
    <div class="titulo">Rotation</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/12_rotation/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL</div>
    <div class="descricao">
        Agora, nós iremos aplicar rotação à nossa textura. Na verdade, não iremos rotacionar a textura em si, e sim o quadrado ao qual ela está anexada. A função render() em LTexture agora recebe mais um argumento, que especifica quantos graus o quadrado será
        rotacionado. Neste tutorial, nós queremos rotacionar a imagem em torno do próprio centro. Para isto, usaremos a função glRotate(), mas antes devemos colocar o ponto de rotação no centro da imagem. A função glRotate() fará a rotação em torno do
        ponto de translação atual. No código, nós transladamos para o centro da imagem ao adicionar o deslocamento fornecido mais metade do tamanho do nosso quadrado. Então, nós rotacionamos o quadrado usando glRotate(). O primeiro argumento da função
        é quantos graus você quer rotacionar. Os próximos tres argumentos são os componentes (x, y, z) do vetor. Nosso código faz a rotação em volta do eixo z positivo. glRotate() recebe como argumento um vetor normalizado, mas irá normalizar qualquer
        vetor dado. A função update() finalmente fará alguma coisa. Nós queremos que a imagem rotacione a cada segundo, então, adicionamos o angulo de rotação dividido pelo número de frames por segundo. Finalmente, na função render() nós renderizamos
        nossa textura rotacionada. Relembrando que, o que nós estamos rotacionando é o quadrado em que a textura se anexa. Você deve estar se perguntando porque não fizemos o cálculo de rotação na função render(). Em um apropriado para jogos, a função
        de renderização nunca atualiza objeto algum, ela cuida apenas de renderizá-los como eles são. Se você nunca chamar a função update(), a função render() deverá sempre renderizar a mesma coisa.
    </div>
</section>

<section>
    <div class="numeroTutorial">13</div>
    <div class="titulo">Matrix Rotations</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/13_matrix_transformations/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL</div>
    <div class="descricao">
        Neste tutorial vamos utilizar transformações matriciais para rotacionar uma textura sem alterar sua composição original.
        Em LTexture não vamos chamar aqui a nossa matriz identidade, para não perder qualquer transformação feita, de resto é semelhante
        aos tutoriais passados.
        Em LUtil temos 3 coisas importantes: A nossa textura que será rotacionada, o ângulo de rotação e o estado de transformação.
        loadMedia() e update() carregam e atualizam nossa textura, respectivamente. Dentro de LUtil, vamos chamar nossa matriz identidade
        para renderizar nosso componente e vamos aplicar as transformações.
        Para mudar nosso componente para qualquer posição da tela usamos glTranslate(), depois usamos glRotate() para rotacionar em torno de algum ponto
        da tela, usamos glScale() para manipular o tamanho da figura .
       
       Caso 0:
            A figura tem o seu centro no centro da tela e rotaciona no eixo desse centro.
       Caso 1:
            A parte superior direita da imagem estará no centro da tela e a figura rotacionará com base no novo centro.
       Caso 2:
            Neste caso mudamos primeiro o tamanho da figura, como mudamos o tamanho da figura, o novo centro também sera alterado
            girando no canto inferior direito da tela.
       Caso 3:
            As coordenadas (0, 0) da imagem estarão exatamente no centro da tela onde será rotacionada em torno do centro.
       Caso 4:
            Rotacionamos primeiro fazendo a figura girar em torno do canto superior esquerdo da tela.
    </div>
</section>


<section>
    <div class="numeroTutorial">14</div>
    <div class="titulo">Repeating Textures</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/14_repeating_textures/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGL.GLU, OpenGL.GLUT</div>
    <div class="descricao">
        Neste tutorial, vamos criar um efeito de mosaico fazendo modificações nas coordenadas de textura.
        Primeiro vamos configurar a nossa textura padrão e vamos passar a ela GL_REPEAT que forma um padrão de repetição. Depois,
        vamos carregar a nossa textura e defini-las usando glTexParameter() para os eixos s e t. Em LUTil vamos declarar variaveis
        globais, a primera delas vai nos apontar para a textura que queremos marcar. A segunda vai ter as compensaçoes de textura para
        nos usarmos quando for rolar a textura na tela e gTextureWrapType que controla o revestimento da textura. Vamos usar loadMedia()
        para carregar nossa textura, como nos tutoriais anteriores. A nossa função update() vai atualizar o compensamento de textura
        para dar a sensação de rolagem na tela. E também redefinimos as coordenadas sempre que ela passa do limite da tela permitindo
        a continuação do loop. Dentro de render() vamos calcular as coordenadas da textura em função do canto direito inferior da tela
        Agora vamos usar a textura carregada com glBindTexture(), em seguida definimos a matriz atual como a matriz de textura e iniciali-
        zamos ela. Após a inicialização da matriz, vamos passar para o offset de textura dividindo cada offset pelo comprimento
        da textura e depois vamos renderizar nossa textura. Conforme o usuário pressiona "q" vamos alterar entre GL_REPEAT e GL_CLAMP,
        o primeiro continua mapeando e repetindo além da textura e o segundo mapeia apenas até o limite da textura, se passar ela será
        suprimida dentro do limite.
    </div>
</section>


<section>
    <div class="numeroTutorial">15</div>
    <div class="titulo">Extensions</div>
    <div class="linkdotutorial">http://lazyfoo.net/tutorials/OpenGL/15_extensions_and_glew/index.php</div>
    <div class="bibliotecas">OpenGL.GL, OpenGL.GLU, OpenGL.GLUT</div>
    <div class="descricao">
        Neste tutorial, usaremos diferentes formas de envelopamento de textura.
	Em opengl 1.1 há apenas dois modos de envelopamento de textura, já em opengl 2.1 há cinco tipos.
	Basicamente, nosso programa é o mesmo de antes, com a diferença de que agora usamos cinco formas 
	de envelopamento da textura. Além das que já tinhamos, agora temos GL_CLAMP_TO_BORDER que fará a textura 
	parar de ser mapeada além de 0.0 ou 1.0. GL_CLAMP_TO_EDGE que usará valores texel (pixels de textura) no limite da textura 
	e irá repetir até o limite do polígono, como se a imagem fosse esticada. E GL_MIRRORED_REPEAT que irá repetir a textura para valores além de 
	0.0 e 1.0, com a diferença de que a textura será espelhada a cada repetição.
    </div>
</section>

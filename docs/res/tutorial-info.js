function get_info_api() {
    return [
        { 'Link': 'http://lazyfoo.net/tutorials/OpenGL/01_hello_opengl/index.php', 'Titulo': 'Hello OpenGL', 'Numero': '01', 'Descricao': '\r\n        No primeiro tutorial o nosso objetivo principal é exibir na tela uma aplicação gráfica que desenha na tela uma figura quadrangular. Para isso vamos utilizar as bibliotecas OpenGl.GL, OpenGl.GLU e OpenGl.GLUT tornando a nossa aplicação portável para outras\r\n        janelas. Vamos utilizar também a biblioteca LUtil para utilizar as funções de loop para mantes nossa aplicação rodando e também para utilizar as funções de inicialização. As constantes da biblioteca SCREEN_WIDTH, SCREEN_HEIGHT E SCREEN_FPS inicializam\r\n        largura, altura e frames respectivamente. Ainda na biblioteca LUtil usaremos as funções update() e render() para atualizar a lógica e processar a nossa aplicação, no nosso caso a aplicação não tem nada para ser atualizado então nossa função update\r\n        ficarásem argumentos e corpo. Essas funções e constantes são extremamente importantes para criar um contexto válido para a nossa aplicação OpenGL. Vamos usar também a função glMatrixMode() que especifica qual a matriz vai ser utilizada, glLoadIdenty()\r\n        para utilizar como auxiliar da nossa matriz. Vamos definir cor para a nossa aplicação através da função glClearColor(), o sistema utilizado para colorir é o RGB (Red, Green, Blue) com valores que variam de 0 à 255 e o argumento Alpha, após isso\r\n        vamos usar glGetError() para informar possíveis erros da aplicação. Dentro do render() vamos limpar o buffer de cor com a função glClear(). Após limpar a tela vamos usar glBegin() para iniciar o desenho da nossa figura, essa função delimita os\r\n        vértices de uma figura, nessa função a ordem dos parâmetros importa, pois ligara um vértice ao seu posterior. Após delimitar nossa figura, vamos envia-la para a Unidade de Processamento Gráfico(GPU), através da função glVertex() passando as coordenadas\r\n        x , y, z... quantas dimensões você quiser utilizar. No nosso caso vamos usar apenas 2 dimensões. Após passar as coordenadas vamos enviar as nossas coordenadas e renderizar nossa figura usando a função glEnd(). Para atualizar a tela com a nossa\r\n        figura vamos usar glSwapBuffers(), paracriar 2 buffers um para o usuário e um para memória onde vai ser atualizado e depois vai ser invertido com o outro buffer. glutInitDisplayMode() e glutInitWindowSize() irão definir um display inicial e o\r\n        tamanho inicial da nossa janela e glutCreateWindow()criará a janela e podemos passar um nome para ela como parâmetro. Queremos agora que a nossa figura seja exibida constantemente na tela, para isso vamos chamar uma função de loop chamada glutTimerFunc()\r\n        para executar o frame. Agora vamos criar nossa função de loop principal que chama as outras funções de loop, a função glutMainLoop() para fazer todos os eventos GLUT entratem em loop, fazendo assim nossa figura ser exibida na tela.\r\n    ', 'Bibliotecas': 'OpenGL.GL, OpenGl.GLU, OpenGL.GLUT' },
        { 'Link': 'http://lazyfoo.net/tutorials/OpenGL/02_matrices_and_coloring_polygons/index.php', 'Titulo': 'Matrices and Coloring Polygons', 'Numero': '02', 'Descricao': "\r\n        No tutorial 02 vamos utilizar um sistema de coordenadas com as dimensões 640x480 e vamos também colori-lo. Primeiro, na nossa biblioteca auxiliar LUtil, vamos definir o tamanho da tela que iremos trabalhar e definir a quantidade de frames por segundo\r\n        com as contantes SCREEN_WIDTH, SCREEN_HEIGHT E SCREEN_FPS . Vamos também iniciar as cores do desenho como a constante COLOR_MODE_CYAN = 0 E COLOR_MODE_MULTI = 1 . Ainda em LUtil vamos chamar a função glInit() e vamos fazer os processos idênticos\r\n        do Tutorial 01 , usando as funções glMatrixMode() e glLoadIdenty() mas adicionaremos uma nova função, a glOrtho() que multiplica a matriz atual por uma matriz ortográfica (2 dimensões) usando os valores esquerdo, direito , cima , baixo, perto\r\n        e longe como argumentos. A nossa função update() continuará sem utilidade. Na função render() vamos limpar o buffer de cor com glClear() e vamos utlizar uma matriz Model_View para aplicar mudanças na nossa figura. A diferença entre a Model_View\r\n        e a Model_Projection é que uma controla a visualização e a outra controla a renderização. Vamos usar a função glTranslate() para mudar nossa figura do canto superior esquerdo , para o centro da tela. Após isso, vamos definir a próxima cor do vértice\r\n        com a função glColor() usando parâmetros do sistema RGB e vamos definir a posição do vértice com glVertex(). Observe que quando enviamos um vertice o OpenGL toma como cor base a ultima cor passada. Não podemos esquecer de atualizar a tela com\r\n        a função glutSwapBuffers(). Outra novidade é a função handleKeys() que vamos usar para verificar a tecla pressionada e realizar uma ação se tal condição for satisfeita. No nosso caso se 'q' for pressionado ele troca de Ciano para Colorido ou vice-versa.\r\n        Também vamos usar a tecla 'e' para mudar a escala do nosso desenho , usando a função gProjectionScale, vamos mudar ela para o dobro do tamanho, depois para metade do tamanho e depois ela volta para o tamanho inicial. A função main() é exatamente\r\n        igual a do Tutorial 01 , muda apenas a adição de glutKeyboardFunc() para o uso do teclado.\r\n    ", 'Bibliotecas': 'OpenGL.GL, OpenGl.GLU, OpenGL.GLUT' },
        { 'Link': 'http://lazyfoo.net/tutorials/OpenGL/03_the_viewport/index.php', 'Titulo': 'The Viewport', 'Numero': '03', 'Descricao': '\r\n        Neste tutorial vamos utilizar o viewport para podermos trabalhar com diferentes partes da tela , essa ferramenta é muito utilizada no desenvolvimento de jogos, pode ajudar também na portabilidade do jogo para diferentes tamanhos de tela. O viewport define\r\n        a área da tela que iremos trabalhar . Nosso código do LUtil irá receber algumas mudanças. Na função initGL() vamos adicionar uma chamada a função glViewPort() , que define qual parte da tela vamos renderizar recebendo x e y para inicio da renderização\r\n        e largura e altura do nosso componente. Utilizando VIEWPORT_MODE_FULL estamos dizendo para o programa que vamos utilizar a tela inteira para a renderização do nosso desenho. Dentro da nossa função render() vamos usar vários tipos de viewport.\r\n        Primeiro, após limpar o buffer de cor da tela, e mudas nosso componente para o centro da tela com glTranstale(). Agora vamos utilizar VIEWPORT_MODE_HALF_CENTER que renderiza o nosso componente para apenas a metade da tela, como estamos usando\r\n        640x480 nosso desenho será 320x240 . Utilizando VIEWPORT_MODE_HALF_TOP vamos passar para o compilador que queremos apenas a metade superior da tela para a renderização do nosso desenho. Com VIEWPORT_MODE_QUAD podemos desenhar diversos componentes\r\n        por toda a tela , inclusive de cores diferentes. E , por último , VIEWPORT_MODE_RADAR que nos permite criar uma versão reduzida de todo o nosso desenho e por na tela com ele completo . É muito utilizado em jogos para fazer mapas, radares. Você\r\n        já deve ter visto no Counter-Strike Need For Speed e em outros diversos jogos. Após criar as viewport vamos utilizar a nossa ja conhecida função handleKeys() para percorer os vários viewport definidos no nosso código. O código da nossa função\r\n        main() é idêntico ao do tutorial 02 .\r\n    ', 'Bibliotecas': 'OpenGL.GL, OpenGl.GLU, OpenGL.GLUT' },
        { 'Link': 'http://lazyfoo.net/tutorials/OpenGL/04_scrolling_and_the_matrix_stack/index.php', 'Titulo': 'Scrolling and the Matrix Stack', 'Numero': '04', 'Descricao': '\r\n        No tutorial-04, nós vamos realizar transformações na matriz de modelo de exibição (modelview) para mover a área que será renderizada na tela. Em outras palavras, movimentaremos a câmera para renderizar uma área diferente. Logo no início da nossa biblioteca\r\n        LUtil.py, nós definimos as coordenadas x e y da câmera, com "gCameraX" e "gCameraY". A função initGL() é basicamente a mesma do tutorial-03, apenas adicionamos a função glPushMatrix() para salvar a matriz de modelo de exibição na pilha. No contexto\r\n        atual (OpenGL 2.1) nós temos a matriz de projeção e de modelo de exibição (GL_PROJECTION e GL_MODELVIEW), além de outras duas apresentadas na documentação. Cada uma dessas matrizes possui uma pilha associada a ela, você pode adicionar uma cópia\r\n        da matriz atual à pilha, salvando-a para mais tarde. Como dito no começo do tutorial, nós iremos realizar translações na matriz de modelo de exibição, no entanto, diferente do tutorial-02, desta vez nós não iremos fazer a chamada das funções glLoadIdentity()\r\n        e glOrtho() a cada modificação. Nós iremos empilhar uma cópia da matriz de modelo de projeção inicial movida para a posição da câmera, salvando-a para quando seja necessário fazer modificações na mesma. Aplicar transformações da câmera à matriz\r\n        de projeção, como foi feito no tutorial-02, é considerado uma má prática visto que isto causa interferências no cálculo de iluminação e névoa. Fizemos desta forma apenas por questão de simplicidade. Obs: A pilha de matrizes não é infinita, empilhar\r\n        muitas matrizes pode causar o retorno de GL_STACK_OVERFLOW da função glGetError(). Na função handleKeys() nós modificamos a posição da câmera quando o usuário pressiona as teclas w, a, s ou d. Já que nós mudamos a posição da câmera, alterando\r\n        o valor de suas coordenadas, quando o usuário pressiona uma tecla, precisamos também alterar o valor padrão da matriz da câmera. Primeiro, desempilhamos a antiga matriz padrão para a matriz atual com glPopMatrix(). Então, carregamos a matriz identidade\r\n        na matriz atual com glLoadMatrix(). E transladamos a matriz de modelo de exibição pela deslocação da câmera, feito isto, a cena será renderizada relativamente à camera. Agora, como nós desempilhamos a matriz padrão, precisamos empilhar a nossa\r\n        nova matriz no topo da pilha com glPushMatrix() para salva-la. Na função render(), no lugar de usar glLoadIdentity() para redefinir a matriz, usaremos glPopMatrix() para carregar a matriz que acabamos de salvar com a translação da câmera. Isto\r\n        porque nós precisamos desta matriz para o próximo frame. Então, a reempilhamos imediatamente. Agora que a matriz de modelo de exibição renderiza tudo em relação à camera, nós podemos começar a renderizar os vértices. Renderizamos uma cena que\r\n        tem o dobro do tamanho da altura e largura da camera. Os vértices nunca deslocam sua posição, apenas a câmera. Neste tutorial, a única transformação que aplicamos foi a translação com glTranslate(). Se você quiser aumentar ou diminuir o zoom,\r\n        pode escalar a matriz usando glScale(). Ou rotacioná-la, usando glRotate(). Todas presentes na documentação.\r\n    ', 'Bibliotecas': 'OpenGL.GL, OpenGl.GLU, OpenGL.GLUT' },
        { 'Link': 'http://lazyfoo.net/tutorials/OpenGL/05_texture_mapping_and_pixel_manipulation/index.php', 'Titulo': 'Texture Mapping and Pixel Manipulation', 'Numero': '05', 'Descricao': '\r\n        Neste tutorial vamos criar a textura de um tabuleiro de xadrez e depois vamos mapea-lo. Primeiro, vamos criar a nossa biblioteca LTEXTURE e dentro dela vamos definir a nossa classe que se chamará LTexture também. Temos que criar um construtor e também\r\n        um destrutor da nossa classe . Após isso, vamos criar os nossos métodos. Primeiro deles é o loadTextureFromPixels32() que recebe os dados da textura a ser criada e gera uma nova textura. Temos uma função para liberar da me- moria desalocando os\r\n        dados da textura. Dentro da nossa função render() vamos posicionar a nossa textura e mapea-lo e vamos por métodos de consulta da nossa classe como getTextureId(), textureWidth() e textureHeight() , para passar o identificador , largura e altura\r\n        da nossa textura. Antes de começar a carregar os dados, temos que ter certeza que não está com lixo a textura, para depois atribuir as dimensões. Definimos a função glGenTextures() para gerar um identificador para a nossa textura. Com a a função\r\n        glTexImage2D() vamos passar todos o argumentos para o nosso gerador de textura como: tipo, formato dos pixels com a textura armazenada, largura, altura, formato dos dados, largura da borda, e o endereço dos pixels que você está passando. Com a\r\n        função glTexParameter() vamos definir de que modo a textura será exibida. Na nossa função render() vamos verificar se existe uma textura a ser criada, definir a posição dela na tela e passar os dados para cria-la. Agora vamos chamar a função glTexCoord()\r\n        para passar uma textura á um vértice, de forma parecida de como passavamos uma cor a um vértice nos tutoriais anteriores. As texturar não trabalham como coordenas x, y, z e sim com eixos, o horizontal e o vertical e esses eixos variam de 0 à 1,\r\n        mesmo que a quantidade de texturas/pixels seja superior a 1. Dentro de glInit() vamos adicionar a função loadMedia() para carregar os pixels da textura e glEnable() para habilitar a textu- rização em 2D. Vamos passar 128x128 para loadMedia() para\r\n        o tamanho do nosso tabuleiro. Para colorir vamos por uma verificação, se o quinto bit de x e y são diferentes vamos passar branco, senão, passaremos vermelho (sempre com RGB). Por fim vamos rendezirar o tabuleiro no centro da tela.\r\n    ', 'Bibliotecas': 'OpenGL.GL, OpenGl.GLU, OpenGL.GLUT' },
        { 'Link': 'http://lazyfoo.net/tutorials/OpenGL/06_loading_a_texture/index.php', 'Titulo': 'Loading a Texture', 'Numero': '06', 'Descricao': '\r\n        No tutorial-06, faremos o mesmo que o tutorial-05. Mas, desta vez carregaremos a imagem à partir de um arquivo. Visto isto, é importante que o arquivo a ser carregado esteja em uma pasta visível pelo python, de preferência na mesma em que se encontra\r\n        o arquivo "main.py". Em "LTexture.py" nós iremos importar a classe "Image" e o método "open" da biblioteca PIL. loadTextureFromFile() é a nossa nova função para carregar texturas a partir de um arquivo, que recebe uma string com o caminho do arquivo\r\n        como argumento. Logo no começo da funçao, temos a nossa flag de textura carregada. Nas próximas linhas, nós carregamos nosso arquivo com a função open(), e convertemos os dados dos pixels para o padrão RGBA com o método de classe tobytes(). Agora,\r\n        basta passar as informações para a função loadTextureFromPixels32(), apresentada no tutorial anterior, para gerar as texturas. Os índices 0 e 1 do vetor da imagem representam a largura e altura, respectivamente. Após carregar a textura, é uma\r\n        boa prática fechar o arquivo com close(). Na nossa biblioteca LUtil, habilitaremos o uso de texturas com glEnable() na função initGL(). E faremos a chamada da função loadTextureFromFile() para carregar nossa imagem. Tenha certeza de que o arquivo\r\n        "opengl.png" se encontre na mesma pasta que os arquivos python. Por fim, na função render(), faremos o mesmo que foi feito no tutorial-05.\r\n    ', 'Bibliotecas': 'OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL' },
        { 'Link': 'http://lazyfoo.net/tutorials/OpenGL/07_clipping_textures/index.php', 'Titulo': 'Clipping Textures', 'Numero': '07', 'Descricao': '\r\n        Neste tutorial vamos mapear apenas partes de uma textura para renderizar imagens em folhas de sprite. Folhas de sprite são usadas, principalmente, para animações exibindo uma sequencia de frames de imagens. Na bilioteca LFRECT vamos definimos em que parte\r\n        da imagem vamos trabalhar. Na biblioteca LTEXTURE, vamos definir a área da textura que iremos utilizar ( podemos passar NULL para trabalhar como ele completo). Depois vamos definir as coordenadas de textura para aplicar no nosso vértice, temos\r\n        sempre que calcular isso, pois não sa- bemos se vamos trabalhar com a imagem completa ou parte dela, para isso temos variaveis para calcular as coordenadas que vamos usar. Para calcular a textura temos que converter para 0/1. Ex:(Em uma imagem\r\n        de 256 p , se eu quero a matede tenho que passar 0,5 e não 128 tanto para largura quanto para altura ). Com essas informaçoes podemos renderizar a nossa folha de sprite. Em LUTIL declaramos a nossa folha de sprite e criamos um vetor de retangulos.\r\n        Na função loadMedia() definimos os retangulos e carregamos as texturas. E na função render() renderizamos os sprites de cada array em cada canto da tela da nossa imagem.\r\n    ', 'Bibliotecas': 'OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL' },
        { 'Link': 'http://lazyfoo.net/tutorials/OpenGL/08_non_power_of_2_textures/index.php', 'Titulo': 'Non-Power-of-Two Textures', 'Numero': '08', 'Descricao': '\r\n        No tutorial-08, nós vamos renderizar uma imagem de 520x235 pixels e preenche-la numa textura de 1024x256. A forma como nós vamos renderizar uma textura que não é potência de dois (520x120) é tornar a imagem maior, preenchendo-a com pixels (512x128), e\r\n        então cortar a parte da textura com a imagem real nela. Para fazer isto nossa função loadTexturefromPixels32() sofreu modificações, pois nós precisamos saber o tamanho da imagem original e o tamanho da textura preenchida. Por isso, adicionamos\r\n        variáveis à classe LTexture para armazenar as dimensões tanto da imagem quanto da textura. Há também a adição da função powerOfTwo(), que usaremos para calcular o quanto será preciso redimensionar a textura. Por exemplo, se lhe dermos o argumento\r\n        60, ela retornará 64. Em LTexture.py, importaremos o arquivo LFRect, que importa a biblioteca PIL, para usar as funções de abertura de imagem. E em nosso construtor, inicializaremos as dimensões da textura e imagem. Em loadTextureFromFile() faremos\r\n        o carregamento e conversão da imagem como de costume. Porém, desta vez devemos ter certeza de pegar a largura e altura da imagem original. Após carregar a imagem, usaremos a função powerOfTwo() para calcular as novas dimensões da imagem para que\r\n        ela seja potência de dois. E então verificamos se as novas dimensões e as dimensões originais não são iguais. Já que se a imagem carregada já tenha dimensões em potência de dois não faz sentido redimensioná-la. Caso a imagem precise ser redimensionada,\r\n        definiremos sua origem como sendo o canto superior-esquerdo para que quando a imagem seja preenchida os pixels sejam adicionados na parte inferior/direita. Para preencher a imagem nós esticamos o canvas para as dimensões da textura. Com a nossa\r\n        imagem pronta, nós a enviamos para a função loadTextureFromPixels32(). O que faremos aqui é basicamente o mesmo, com a diferença de que agora nós definimos as dimensões tanto da imagem quanto da textura. Na função render(), definiremos as coordenadas\r\n        da textura como sendo a proporção entre as dimensões da imagem original e da textura. Isto para que a parte que foi preenchida seja cortada da renderização. Nosso destrutor é basicamente o mesmo, com adição de que ele agora retorna as dimensões\r\n        para 0. Preencher uma imagem de 520x235 para uma textura de dimensões 1024x256 consome muitos pixels. Por este motivo, é uma boa prática colocar várias imagens em uma textura para usar a memória da GPU da forma mais eficiente o possível.\r\n    ', 'Bibliotecas': 'OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL' },
        { 'Link': 'http://lazyfoo.net/tutorials/OpenGL/09_updating_textures/index.php', 'Titulo': 'Updating Textures', 'Numero': '09', 'Descricao': '\r\n        Neste tutorial nos vamos criar um circulo com seu background preto e adicionar listras na sua diagonal. A nossa biblioteca LTexture terá a adição de uma nova variável, se chamará mPixels que vai armazenar os dados dos pixels da textura que iremos manipular.\r\n        Temos também, ainda em LTexture a função lock() que obtém os pixels da textura para operarmos com ele,e a função unlock() que envia os dados depois de operados para a textura. A função getPixelData() retorna para nós um apontador para o vetor\r\n        de pixels e as funções getPixel32() e setPixel32() enviam e recebem respectivamente pixels individuais da nossa textura. Agora, antes de chamarmos nossa função FreeTexture(), temos que verificar se existe algum pixel no nosso vetor para ser liberado.\r\n        Para usar a função lock() temos que verificar se ela já não esta manipulando alguma textura e se os pixels da nossa textura existem. Após essa verificação vamos alocar memória para nossos dados que serão copiados. Após isso nós vamos associar\r\n        os dados recebidos com a função glTexImage() e depois vamos desvincular essa textura. Após terminar as nossas manipulações nós vamos enviar de volta os pixels da nossa textura, para isso, vamos utilizar a função glTexSubImage2D() que especifica\r\n        uma textura bidimensional e passa a uma textura destino e depois vamos atualizar nossa textura. Uma coisa importante a salientar é que nossos pixels de textura ficam armazenados em uma matriz unidimensional, ou seja, em um vetor, assim, para obter\r\n        uma coor- denada 2D você tem que transformar em um índice 1D. Dentro de LUtil nós vamos carregar nossa textura e usar lock() para obter os pixels e vamos bloquea-lo para podermos modifica- los. Vamos criar a nossa cor preta para passar aos pixels,\r\n        depois vamos percorrer todos os pixels, se algum deles for o nosso alvo, nós vamos modifica-lo para um preto transparente. Agora vamos percorrer todas as linhas e colunas e vamos mudar algumas delas para colorir nossa diagonal. Depois disso usamos\r\n        unlock() para desbloquear a textura e atualizamos a mesma. E, dentro de render(), vamos processar a nossa figura.\r\n    ', 'Bibliotecas': 'OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL' },
        { 'Link': 'http://lazyfoo.net/tutorials/OpenGL/10_color_keying_and_blending/index.php', 'Titulo': 'Color Keying and Blending', 'Numero': '10', 'Descricao': '\r\n        Neste tutorial vamos transformar a borda branco, em uma borda transparente e a imagem central será totalmente cinza. Em LTexture vamos ter 3 novas funções para este tutorial. A primeira delas é loadPixelsFromFile() que carrega as os pixels da textura\r\n        que iremos utilizar. Usaremos também loadTextureFromPixels32() que cria uma textura através dos seus pixels e, finalmente, loadTextureFromFileWithColorKey() que usa as funções loadPixelsFromFile() e loadTextureFromPixels32() para carregar uma\r\n        cor de textura com uma chave, ela recebe o caminho do arquivo e os componentes RGBA da cor a ser tornada transparente. No início de nossa função loadPixelsFromFile() nós vamos liberar qualquer dado de textura que possa existir. Outra diferença\r\n        na nossa função é que não vamos precisar criar uma nova textura do zero, nós vamos alocar memória para receber os dados copiados através da função memcpy() que recebe o destino dos dados, a origem dos a serem copiados e o tamanho dos dados, no\r\n        nosso caso são 4 bytes por pixel, então vamos passar 4 como terceiro argumento. Depois disso vamos sobrecarregar a função loadTextureFromPixels32() usando pixels-membro para criar a nossa textura. Após isso vamos fazer o chaveamento de cores,\r\n        vamos percorrer os nossos pixels e se encontrarmos valores iguais RGB ou RGBA e vamos criar uma textura a partir desses pixels. Agora, dentro de LUtil, precisamos habilitar uma possível mistura de cores, para isso, vamos usar a função glEnable().\r\n        Depois vamos desativar a verificação de profundidade com a função glDisable(), pois isso é utilzado apenas em aplicativos 3D ( que não é o nosso caso neste tutorial). Por fim, vamos criar nossa mistura cm a função glBlendFunc(), primeiro argumento\r\n        que vamos passar é como os seus pixels de origem serão considerados ( ele irá verificar se o poligono que vc está criando existe), e o segundo são os pixels de destino, vamos passar 1 como destino, pois essa função utiliza 0 à 1 como escala e\r\n        a origem será alfa. Agora o nosso circulo terá borda transparente. Após todos esses passos, vamos renderizar nossa figura, mas antes disso vamos fazer uma chamada a glColor4f() para passar 50% como alfa global.\r\n    ', 'Bibliotecas': 'OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL' },
        { 'Link': 'http://lazyfoo.net/tutorials/OpenGL/11_stretching_and_filters/index.php', 'Titulo': 'Stretching and Filters', 'Numero': '11', 'Descricao': '\r\n        Neste tutorial nós vamos definir quadrados de tamanhos diferentes para esticar a nossa textura e usaremos filtros para controlar como ficará a textura quando esticada. A função render() agora tem um argumento adicional: Um retângulo, para definir o quanto\r\n        a textura será esticada, que terá valor padrão NULL para o caso de não desejarmos esticar a textura. As coordenadas da nossa textura na função render() funcionam do mesmo jeito que antes. O que muda é que iremos passar coordenadas diferentes para\r\n        os vértices. Quando a nossa função possuir um retangulo de esticamento, as dimensões do nosso quadrado serão iguais ao tamanho do retângulo. Então, quando nosso quadrado com textura for renderizado, a textura será esticada para preencher o novo\r\n        tamanho do quadrado. Declararemos algumas variáveis globais no topo da biblioteca LUtil.py. "gStretchedTexture" é a textura que nós vamos carregar, de 160x120 pixels. "gStretchRect" é o retângulo que usaremos para esticar a textura para o tamanho\r\n        da tela. "gFiltering" será responsável por controlar como a textura será filtrada quando renderizada. A melhor forma de explicar como o filtro funciona é através de demonstração. Faremos isso com a nossa função handleKeys(). Na função loadMedia()\r\n        nós carregamos a nossa textura e na função render() nós a esticamos para o tamanho da tela. Quando o usuário pressiona a tecla \'q\', nós ativamos e mudamos o filtro da nossa textura. Isto é possíve mesmo que estejamos fora da classe LTexture, contanto\r\n        que tenhamos a ID da textura que desejamos realizar as operações. As funções utilizadas para tal devem lhe parecer familiares, pois já foram usadas na função que carrega a textura. "GL_TEXTURE_MAG_FILTER" controla como a textura é filtrada quando\r\n        esticada. O valor padrão que colocamos quando carregamos a textura é "GL_LINEAR". Isto significa que a nossa textura "mistura" os pixels ao ser esticada. Quando mudado para "GL_NEAREST", o opengl apenas pega o valor texel mais próximo, o que resulta\r\n        numa imagem mais granulada. Vale notar que "GL_TEXTURE_MIN_FILTER" controla o filtro da textura quando ela é comprimida para um tamanho menor. Os valores dos dois não precisam ser iguais caso você queira aplicar filtros diferentes em situações\r\n        diferentes.\r\n    ', 'Bibliotecas': 'OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL' },
        { 'Link': 'http://lazyfoo.net/tutorials/OpenGL/12_rotation/index.php', 'Titulo': 'Rotation', 'Numero': '12', 'Descricao': '\r\n        Agora, nós iremos aplicar rotação à nossa textura. Na verdade, não iremos rotacionar a textura em si, e sim o quadrado ao qual ela está anexada. A função render() em LTexture agora recebe mais um argumento, que especifica quantos graus o quadrado será\r\n        rotacionado. Neste tutorial, nós queremos rotacionar a imagem em torno do próprio centro. Para isto, usaremos a função glRotate(), mas antes devemos colocar o ponto de rotação no centro da imagem. A função glRotate() fará a rotação em torno do\r\n        ponto de translação atual. No código, nós transladamos para o centro da imagem ao adicionar o deslocamento fornecido mais metade do tamanho do nosso quadrado. Então, nós rotacionamos o quadrado usando glRotate(). O primeiro argumento da função\r\n        é quantos graus você quer rotacionar. Os próximos tres argumentos são os componentes (x, y, z) do vetor. Nosso código faz a rotação em volta do eixo z positivo. glRotate() recebe como argumento um vetor normalizado, mas irá normalizar qualquer\r\n        vetor dado. A função update() finalmente fará alguma coisa. Nós queremos que a imagem rotacione a cada segundo, então, adicionamos o angulo de rotação dividido pelo número de frames por segundo. Finalmente, na função render() nós renderizamos\r\n        nossa textura rotacionada. Relembrando que, o que nós estamos rotacionando é o quadrado em que a textura se anexa. Você deve estar se perguntando porque não fizemos o cálculo de rotação na função render(). Em um apropriado para jogos, a função\r\n        de renderização nunca atualiza objeto algum, ela cuida apenas de renderizá-los como eles são. Se você nunca chamar a função update(), a função render() deverá sempre renderizar a mesma coisa.\r\n    ', 'Bibliotecas': 'OpenGL.GL, OpenGL.GLU, OpenGL.GLUT, PIL' }
    ];
}
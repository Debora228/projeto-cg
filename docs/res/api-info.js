function get_info_api() {
 	return [
{'Função': 'initGL', 'Descrição': 'Inicializa recursos de inicialização do OpenGL, como por exemplo, a definição da cor de limpeza.', 'Variações da Função': '', 'Retorno': 'bool', 'Protótipo': 'bool initGL(void)', 'Parâmetros': 'void'},
 {'Função': 'render', 'Descrição': 'Função onde serão renderizados todos os objetos que serão trabalhados.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void render(void)', 'Parâmetros': 'void'},
 {'Função': 'runMainLoop', 'Descrição': 'Quando chamamos essa função, ele irá executar as funções do loop principal e definir uma chamada de volta para executar-se novamente. Quando o callback é executado, ele irá executar as funções de loop principal e chamar-se novamente em um 60 de segundo.\r\n        Então, o que esse loop de retorno faz é garantir que as funções do loop principal sejam chamadas a cada 60º de segundo para nos dar uma taxa de quadros de 60 quadros por segundo.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void runMainLoop(int val)', 'Parâmetros': 'val - Tempo de retorno'},
 {'Função': 'glMatrixMode', 'Descrição': 'Especifica qual é a matriz atual.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glMatrixMode(GLenum(mode))', 'Parâmetros': 'Variável mode (Especifica qual pilha de matriz é o destino para operações de matriz subsequentes.) Valores aceitos: GL_MODELVIEW, GL_PROJECTION e GL_TEXTURE. Sendo que o valor inicial é GL_MODELVIEW.'},
 {'Função': 'glLoadIdentity', 'Descrição': 'Substitui a matriz atual pela matriz identidade.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glLoadIdentity(void)', 'Parâmetros': 'void'},
 {'Função': 'glClearColor', 'Descrição': 'Especifica valores vermelho, verde, azul e alfa usados para a inicialização do buffer de cores. Os valores iniciais são todos iguais a 0.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glClearColor(GLfloat(red), GLfloat(green), GLfloat(blue), GLfloat(alpha))', 'Parâmetros': 'Variáveis red, green, blue e alpha.'},
 {'Função': 'glGetError', 'Descrição': 'Retorna uma intormação de erro. A cada erro detectado é atribuído um código numérico e um nome simbólico. Quando ocorre um erro, o sinalizador de erro é definido para o valor de código de erro apropriado.', 'Variações da Função': '', 'Retorno': 'Valor da flag de erro do tipo GLenum.', 'Protótipo': 'GLenum glGetError(void)', 'Parâmetros': 'void'},
 {'Função': 'glClear', 'Descrição': 'Limpa os buffers para valores predefinidos por glClearDepth ou glClearStencil.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glClear(GLbitfield mask)', 'Parâmetros': 'Máscaras (tipo GLbitfield) que indicam os buffers a serem limpos. As três máscaras são: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT e GL_STENCIL_BUFFER_BIT.'},
 {'Função': 'glBegin', 'Descrição': 'Delimita os vértices de um tipo primitivo ou um grupo de tipos primitivos.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glBegin(GLenum(mode))', 'Parâmetros': 'Variável mode (Especifica os tipos primitivos que serão criados a partir dos vértices presentes entre o glBegin e o subsequente glEnd) Constantes aceitas: GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN,\r\n        GL_QUADS, GL_QUAD_STRIP e GL_POLYGON.'},
 {'Função': 'glVertex', 'Descrição': 'Especifica um vértice.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glVertex(*args)', 'Parâmetros': 'Coordenadas x,y,z e w do vértice. Nem todos os parâmetros estão presentes em todas as formas do comando.'},
 {'Função': 'glutSwapBuffers', 'Descrição': 'Promove a troca do buffer secundário (atual) e seu conteúdo para se tornar o conteúdo do buffer de frente.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glutSwapBuffers(void)', 'Parâmetros': 'void'},
 {'Função': 'glutTimerFunc', 'Descrição': 'Registra um tempo de retorno a ser acionado em um número especificado de milisegundos.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glutTimerFunc(unsigned int msecs,void (*func)(int value), int value)', 'Parâmetros': 'Milissegundos tipo unsigned int, ponteiro a função do tipo void (*func)(int value) e o tempo de retorno.'},
 {'Função': 'glutInitContextVersion', 'Descrição': 'Utilizada para definir a versão de contexto do OpenGL. Lembrando que esta função não faz parte do GLUT.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glutInitContextVersion(int num1, int num2)', 'Parâmetros': 'Numeração da versão, por exemplo, versão x.y, definiremos como glutInitContextVersion(x,y).'},
 {'Função': 'glutInitDisplayMode', 'Descrição': 'Define um modo de display inicial.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glutInitDisplayMode(unsigned int mode)', 'Parâmetros': 'Variável modo (Modo de exibição). Permite as seguintes máscaras: GLUT_RGBA, GLUT_RGB, GLUT_INDEX, GLUT_SINGLE, GLUT_DOUBLE, GLUT_ACCUM, GLUT_ALPHA, GLUT_DEPTH, GLUT_STENCIL, GLUT_MULTISAMPLE, GLUT_STEREO e GLUT_LUMINANCE.'},
 {'Função': 'glutInitWindowSize', 'Descrição': 'Define o tamanho inicial da janela.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glutInitWindowSize(int width, int height)', 'Parâmetros': 'Variáveis inteiras largura e altura (width e height) em pixels.'},
 {'Função': 'glutCreateWindow', 'Descrição': 'Cria uma nova janela', 'Variações da Função': '', 'Retorno': 'O valor retornado é um identificador inteiro pequeno exclusivo para a janela. O intervalo de identificadores alocados começa em um. ', 'Protótipo': 'int glutCreateWindow(char *name)', 'Parâmetros': 'Uma variável nome (ponteiro a char), que vai ser o nome da janela criada.'},
 {'Função': 'glutDisplayFunc', 'Descrição': 'Define um display de retorno para a janela atual.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glutDisplayFunc(void (*func)(void))', 'Parâmetros': 'Uma função com retorno e parâmetro void.'},
 {'Função': 'glutMainLoop', 'Descrição': 'Faz os eventos GLUT entrarem em processo de loop.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glutMainLoop(void)', 'Parâmetros': 'void'},
 {'Função': 'glEnd', 'Descrição': 'Especifica que os vértices serão enviados e renderiza as figuras.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glEnd(void)', 'Parâmetros': 'void'},
 {'Função': 'glOrtho', 'Descrição': 'Multiplica a matriz atual por uma matriz ortográfica (2D) com os valores right, left, bottom, top, near e far.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glOrtho(GLdouble(left), GLdouble(right), GLdouble(bottom), GLdouble(top), GLdouble(nearVal), GLdouble(farVal))', 'Parâmetros': 'Coordenadas para os planos de corte vertical esquerdo e direito (left, right);<br/>Coordenadas para os planos de corte horizontal superior e inferior (bottom, top);<br/>A distância para os planos de corte de profundidade mais próximo e afastado (nearVal,\r\n        farVal).\r\n    '},
 {'Função': 'glTranslate', 'Descrição': 'Multiplica a matriz atual por uma matriz de translação.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glTranslate(args)', 'Parâmetros': 'Coordenadas x, y e z do vetor de translação.'},
 {'Função': 'glColor', 'Descrição': 'Especifica a cor atual.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'glColor(*args)', 'Parâmetros': 'Valores red, green, blue e alpha.'},
 {'Função': 'handleKeys', 'Descrição': 'Essa função pega um valor ASCII de uma tecla pressionada e a posição atual do mouse. Ela simplesmente alterna a flag boleana quando a tecla é pressionada.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void handleKeys(unsigned char key,int x,int y)', 'Parâmetros': 'Valor da tecla pressionada (key) e a coordenada x e y da posição do mouse.'},
 {'Função': 'glutKeyboardFunc', 'Descrição': 'Especifica a tecla de retorno do teclado para a janela atual.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glutKeyboardFunc(void (*func)(unsigned char key,int x, int y))', 'Parâmetros': 'A nova função de retorno do teclado.'},
 {'Função': 'glViewport', 'Descrição': 'Define um modo de exibição de janela (viewport).', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glViewport(GLint(x), GLint(y), GLsizei(width), GLsizei(height))', 'Parâmetros': 'x e y: especificam o canto inferior esquerdo do retângulo da janela de visualização em pixels. Valor inicial (0,0) width e height: especificam a largura e altura da viewport.'},
 {'Função': 'glPushMatrix', 'Descrição': 'Salva uma cópia da matriz atual e insere em uma pilha para esta ser utilizada mais tarde. Importante lembrar que a pilha de matrizes não é infinita. Inserindo matrizes demais na pilha o programa irá retornar um erro de GL_STACK_OVERFLOW da função\r\n        glGetError().\r\n    ', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glPushMatrix((void))', 'Parâmetros': 'void'},
 {'Função': 'glPopMatrix', 'Descrição': 'Retira a matriz padrão antiga da pilha de matrizes e mescla com a matriz atual.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glPopMatrix((void))', 'Parâmetros': 'void'},
 {'Função': 'glutPostRedisplay', 'Descrição': 'Marca que janela atual precisa ser recarregada.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glutPostRedisplay(void)', 'Parâmetros': 'void'},
 {'Função': 'ord', 'Descrição': 'Retorna o código ASCII daquele caractere.', 'Variações da Função': '', 'Retorno': 'O código ASCII correspondente àquele caractere.', 'Protótipo': 'int ord(char)', 'Parâmetros': 'Um caractere qualquer(char).'},
 {'Função': 'glDeleteTextures', 'Descrição': 'Deleta uma quantidade definida de texturas.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glDeleteTextures(GLsizei(n), const GLuint *(textures))', 'Parâmetros': 'O número de texturas a serem deletadas e o array de texturas que serão deletadas.'},
 {'Função': 'glGenTextures', 'Descrição': 'Gera os nomes de uma quantidade determinada de texturas.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glGenTextures(GLsizei(n), GLuint * (textures)) ', 'Parâmetros': 'O número de nomes de texturas a serem gerados e o array de texturas a serem nomeadas.'},
 {'Função': 'glBindTexture', 'Descrição': 'Vincula uma textura nomeada a uma textura padrão da biblioteca.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glBindTexture(GLenum(target), GLuint(texture))', 'Parâmetros': 'O destino para o qual a textura será vinculada e o nome da textura. As texturas padrão podem ser: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY,\r\n        GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE ou GL_TEXTURE_2D_MULTISAMPLE_ARRAY.'},
 {'Função': 'glTexImage', 'Descrição': 'Especifica uma imagem de textura bidimensional.', 'Variações da Função': 'O valor X pode ser: 2D, 2Df, 2Di, 2Ds, 2Dui, 2Dus. Só havendo diferença entre os tipos de dados aceitos.', 'Retorno': 'void', 'Protótipo': 'void glTexImageX(GLenum (target), GLint (level), GLint (internalFormat), GLsizei(width), GLsizei(height), GLint(border), GLenum (format), GLenum (type), const GLvoid *(data))', 'Parâmetros': 'A textura padrão a ser vinculada (GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,\r\n        GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z ou GL_PROXY_TEXTURE_CUBE_MAP);<br/>- O nível de detalhe;<br/>- O número de componentes coloridos na textura;<br/>- A altura, largura e borda da imagem;<br/>-\r\n        O formato dos dados de pixel (GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL);\r\n        <br/>- O tipo de dado dos dados de pixel (GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,\r\n        GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2 e GL_UNSIGNED_INT_2_10_10_10_REV.);<br/>- Um ponteiro para os dados da imagem\r\n        na memória.'},
 {'Função': 'glTexParameter', 'Descrição': 'Define os parâmetros da textura.', 'Variações da Função': 'O valor de X_type pode ser: const GLint *, const GLuint *, GLfloat, const GLfloat *, GLint, const GLint *.<br/>O valor X pode ser: Iiv, Iuiv, f, fv, i, iv. Respectivamente em relação a X_type.', 'Retorno': 'void', 'Protótipo': 'void glTexParameterX(GLenum (target), GLenum (pname), const X_type * (params))', 'Parâmetros': '- (target) A textura de destino que pode ser: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP;<br/>- (pname) O nome simbólico de um parâmetro de textura de valor único,\r\n        pode ser: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL,\r\n        GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T ou GL_TEXTURE_WRAP_R;<br/>- (param ou params) Um valor para pname ou um ponteiro para um array onde os valores de pneme\r\n        estão guardados.'},
 {'Função': 'glEnable', 'Descrição': 'Habilita algum recurso, a partir da constante GL passada que pode ser:\r\n        GL_ALPHA_TEST, GL_AUTO_NORMAL, GL_BLEND, GL_CLIP_PLANE, GL_COLOR_LOGIC_OP, GL_COLOR_MATERIAL\r\n        GL_COLOR_SUM, GL_COLOR_TABLE, GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, GL_CULL_FACE, GL_DEPTH_TEST,\r\n        GL_DITHER, GL_FOG, GL_HISTOGRAM, GL_INDEX_LOGIC_OP, GL_LIGHT, GL_LIGHTING, GL_LINE_SMOOTH, GL_LINE_STIPPLE,\r\n        GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3,\r\n        GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1,\r\n        GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MINMAX\r\n        GL_MULTISAMPLE, GL_NORMALIZE, GL_POINT_SMOOTH, GL_POINT_SPRITE, GL_POLYGON_OFFSET_FILL, GL_POLYGON_OFFSET_LINE, GL_POLYGON_OFFSET_POINT\r\n        GL_POLYGON_SMOOTH, GL_POLYGON_STIPPLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_RESCALE_NORMAL,\r\n        GL_SAMPLE_ALPHA_TO_COVERAGE, GL_SAMPLE_ALPHA_TO_ONE, GL_SAMPLE_COVERAGE, GL_SEPARABLE_2D, GL_SCISSOR_TEST, GL_STENCIL_TEST,\r\n        GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_GEN_Q, GL_TEXTURE_GEN_R, GL_TEXTURE_GEN_S,\r\n        GL_TEXTURE_GEN_T, GL_VERTEX_PROGRAM_POINT_SIZE, GL_VERTEX_PROGRAM_TWO_SIDE.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glEnable(GLenum)', 'Parâmetros': 'Constantes do tipo GL.'},
 {'Função': 'glPixelStore', 'Descrição': 'Define modos de armazenamento de pixels.', 'Variações da Função': 'O valor de X pode ser: f ou i;<br/>O valor de X_type pode ser: GLfloat ou GLint. Respectivamente em relação a X.', 'Retorno': 'void', 'Protótipo': 'void glPixelStoreX(GLenum(pname), X_type(param))', 'Parâmetros': '(pname) Especifica o nome simbólico do parâmetro a ser definido, pode ser: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES ou GL_PACK_ALIGNMENT. GL_UNPACK_SWAP_BYTES,\r\n        GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES ou GL_UNPACK_ALIGNMENT.<br/>(param) especifica o valor que pname está definido.'},
 {'Função': 'open', 'Descrição': 'Lê uma imagem de um arquivo.', 'Variações da Função': '', 'Retorno': 'Um objeto do tipo imagem.', 'Protótipo': "PIL.Image.open(file,mode='r')", 'Parâmetros': "O caminho para o arquivo e o modo de carregamento (se for usado deve ser 'r')."},
 {'Função': 'close', 'Descrição': 'Retira a imagem da memória.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void Image.close(void)', 'Parâmetros': 'void'},
 {'Função': 'tobytes', 'Descrição': 'Retorna a imagem como um objeto de bytes.', 'Variações da Função': '', 'Retorno': 'Um objeto de bytes.', 'Protótipo': "Image.tobytes(encoder_name='raw', *args)", 'Parâmetros': 'Qual codificador usar (O padrão é usar o codificador padrão "raw") e argumentos extras para o codificador.'},
 {'Função': 'lock', 'Descrição': 'Recebe uma textura, obtem os pixels de textura e retorna se foi possível recupera-los', 'Variações da Função': '', 'Retorno': 'True:Se os pixels de textura foram recuperados, False: se não foi possível recuperar', 'Protótipo': 'bool lock()', 'Parâmetros': 'Uma textura que esteja desbloqueada'},
 {'Função': 'unlock', 'Descrição': 'Recebe uma textura bloqueada, tenta atualizar os pixels de textura e retorna se foi possível atualizar ou não.', 'Variações da Função': '', 'Retorno': 'True: Se os pixels de textura foram atualizados, False: se não foi possível', 'Protótipo': 'bool unlock()', 'Parâmetros': 'Uma textura bloqueada'},
 {'Função': 'getPixelData', 'Descrição': 'Recebe o numero de linhas e colunas de pixels da imagem e retorna um ponteiro para matriz de pixels que podem representar uma paleta de cores no sistema RGB.', 'Variações da Função': '', 'Retorno': 'Um ponteiro para matriz de pixels', 'Protótipo': '*GLuint getPixelData32()', 'Parâmetros': 'void'},
 {'Função': 'getPixel32', 'Descrição': 'Recebe a posição de um pixel e retorna um valor no sistema ARGB.', 'Variações da Função': '', 'Retorno': 'Um valor no sistema ARGB. Retorna 0: Se as coordenadas estão fora dos limites da imagem. Retorna -1: Se o bitmap foi criado opaco e não-transparente', 'Protótipo': 'GLuint getPixel32( GLuint x, GLuint y )', 'Parâmetros': 'Posição X na matriz de pixels, Posição Y na matriz de pixels.'},
 {'Função': 'setPixel32', 'Descrição': 'Define os valores de cor e transparência de um único pixel.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void setPixel32 ( GLuint x, GLuint y, GLuint pixel )', 'Parâmetros': 'Coordenadas do pixel e um valor de cor no sistema ARGB.'},
 {'Função': 'loadPixelsFromFile', 'Descrição': 'Carrega os pixels do Arquivo e faz pads para obter duas dimensões.', 'Variações da Função': '', 'Retorno': 'True: Se carregar com sucesso, False: Se não conseguir.', 'Protótipo': 'bool loadPixelsFromFile( self, File )', 'Parâmetros': 'Caminho para o arquivo.'},
 {'Função': 'loadTextureFromPixels32', 'Descrição': 'Cria uma textura a partir de pixels membros, deleta os pixels membros e reportar erro se não atingir sucesso.', 'Variações da Função': '', 'Retorno': 'True: Se obteve sucesso na criação, False: se houve algum erro.', 'Protótipo': 'bool loadTextureFromPixels32()', 'Parâmetros': 'void'},
 {'Função': 'loadTextureFromFileWithColorKey', 'Descrição': 'Cria uma textura do arquivo fornecido e define uma cor no sistema ARGB para os pixels.', 'Variações da Função': '', 'Retorno': 'True: se sucesso, False: se nao conseguir sucesso.', 'Protótipo': 'bool loadTextureFromFileWithColorKey( std::string path, GLubyte r, GLubyte g, GLubyte b, GLubyte a )', 'Parâmetros': 'Caminho para o arquivo e uma cor no sistema ARGB.'},
 {'Função': 'memcpy', 'Descrição': 'Recebe um destino, uma fonte e numero de bytes a copiar e faz uma copia direta da memoria da fonte para o destino.', 'Variações da Função': '', 'Retorno': 'O destino', 'Protótipo': 'void * memcpy ( void * destination, const void * source, size_t num )', 'Parâmetros': 'matriz destino, a fonte de dados e o numero de bytes a copiar.'},
 {'Função': 'glDisable', 'Descrição': 'Desabilita algum recurso, a partir da constante GL passada que pode ser:\r\n        GL_ALPHA_TEST, GL_AUTO_NORMAL, GL_BLEND, GL_CLIP_PLANE, GL_COLOR_LOGIC_OP, GL_COLOR_MATERIAL\r\n        GL_COLOR_SUM, GL_COLOR_TABLE, GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, GL_CULL_FACE, GL_DEPTH_TEST,\r\n        GL_DITHER, GL_FOG, GL_HISTOGRAM, GL_INDEX_LOGIC_OP, GL_LIGHT, GL_LIGHTING, GL_LINE_SMOOTH, GL_LINE_STIPPLE,\r\n        GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3,\r\n        GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1,\r\n        GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MINMAX\r\n        GL_MULTISAMPLE, GL_NORMALIZE, GL_POINT_SMOOTH, GL_POINT_SPRITE, GL_POLYGON_OFFSET_FILL, GL_POLYGON_OFFSET_LINE, GL_POLYGON_OFFSET_POINT\r\n        GL_POLYGON_SMOOTH, GL_POLYGON_STIPPLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_RESCALE_NORMAL,\r\n        GL_SAMPLE_ALPHA_TO_COVERAGE, GL_SAMPLE_ALPHA_TO_ONE, GL_SAMPLE_COVERAGE, GL_SEPARABLE_2D, GL_SCISSOR_TEST, GL_STENCIL_TEST,\r\n        GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_GEN_Q, GL_TEXTURE_GEN_R, GL_TEXTURE_GEN_S,\r\n        GL_TEXTURE_GEN_T, GL_VERTEX_PROGRAM_POINT_SIZE, GL_VERTEX_PROGRAM_TWO_SIDE.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': 'void glDisable(GLenum)', 'Parâmetros': 'Constantes do tipo GL.'},
 {'Função': 'glScale', 'Descrição': 'Produz uma escala não-uniforme em torno de x, y e z.', 'Variações da Função': 'glScalef ( recebe float ) e glScaled( recebe double )', 'Retorno': 'void', 'Protótipo': 'glScale(x, y, z)', 'Parâmetros': 'x, y, z'},
 {'Função': 'glRotate', 'Descrição': 'Produz uma rotação de um ângulo em torno de x, y e z.', 'Variações da Função': 'glRotatef ( recebe float), glRotaded (recebe double) ', 'Retorno': 'void', 'Protótipo': 'glRotate(angulo, x, y, z)', 'Parâmetros': 'ângulo de rotação, x, y, z(coordenadas)'},
 {'Função': 'glEnableClientState', 'Descrição': 'Ativa recursos individuais a partir da constante passada, são aceitos:\r\n\tGL_COLOR_ARRAY, GL_EDGE_FLAG_ARRAY, GL_FOG_COORD_ARRAY, GL_INDEX_ARRAY, GL_NORMAL_ARRAY, \r\n\tGL_SECONDARY_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY, e GL_VERTEX_ARRAY.\r\n\t', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': ' void glEnableClientState(GLenum)', 'Parâmetros': 'O recurso específico a ser ativado'},
 {'Função': 'glDisableClientState', 'Descrição': 'Desativa recursos individuais a partir da constante passada, são aceitos:\r\n\tGL_COLOR_ARRAY, GL_EDGE_FLAG_ARRAY, GL_FOG_COORD_ARRAY, GL_INDEX_ARRAY, GL_NORMAL_ARRAY, \r\n\tGL_SECONDARY_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY, e GL_VERTEX_ARRAY.\r\n\t', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': ' void glDisableClientState(GLenum)', 'Parâmetros': 'O recurso específico a ser desativado'},
 {'Função': 'glVertexPointer', 'Descrição': 'Define um vetor de dados de vértice.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': ' void glVertexPointer(GLint, Glenum, GLsizei, const GLvoid*)', 'Parâmetros': 'O número de coordenadas por vértice, o tipo de dado, o deslocamento de bytes, apontador para\r\n\t                        a primeira coordenada no vetor de vértices.'},
 {'Função': 'glDrawArrays', 'Descrição': 'Cria uma forma a partir de um vetor de dados.', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': ' void glDrawArrays(GLenum, GLint, GLsizei)', 'Parâmetros': 'O tipo de geometria a ser criada, o índice na matriz de vértices de onde vamos começar a desenhar\r\n\t                        e a quantidade de vértices que serão criados.'},
 {'Função': 'glDrawElements', 'Descrição': 'Usa os elementos em sequencia de uma matriz de índices habilitadas para construir uma figura', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': ' void glDrawElements(GLenum, GLsizei, GLenum, GLvoid *)', 'Parâmetros': 'Alguma constante que especifica o tipo de desenho, o numero de elementos a ser renderizado, o tipo do índice e o local dos índices'},
 {'Função': 'glGenBuffers', 'Descrição': 'Gera nomes para objetos de buffer', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': ' void glGenBuffers(GLsizei, GLuint*)', 'Parâmetros': 'O numero de nome de objetos a serem gerados, a matriz onde serão armazenados '},
 {'Função': 'glBindBuffer', 'Descrição': 'Vincula um objeto a um buffer', 'Variações da Função': '', 'Retorno': 'void', 'Protótipo': ' void glBindBuffer(GLEnum, GLuint)', 'Parâmetros': 'Uma constante GL que é o destino, o nome do objeto '}
	];
 }

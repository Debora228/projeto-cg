<!DOCTYPE html>
<html>
    <head>
        <title>OpenGL em Python</title>
        <meta charset="UTF-8"/>
    </head>
    <body>
        <a id="topo"></a>
        <h1>OpenGL em Python</h1>
        <h2>API OpenGL</h2>

        <section>
            <ul>
                <li><strong>Função: </strong><p>initGL</p></li>
                <li><strong>Descrição: </strong><p>Inicializa recursos de inicialização do OpenGL, como por exemplo, a definição da cor de limpeza.</p></li>
                <li><strong>Parâmetros: </strong><p>void</p></li>
                <li><strong>Retorno: </strong><p>bool</p></li>
                <li><strong>Protótipo: </strong><p>bool initGL(void)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>render</p></li>
                <li><strong>Descrição: </strong><p>Função onde serão renderizados todos os objetos que serão trabalhados.</p></li>
                <li><strong>Parâmetros: </strong><p>void</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void render(void)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>runMainLoop</p></li>
                <li><strong>Descrição: </strong><p>Quando chamamos essa função, ele irá executar as funções do loop principal e definir uma chamada de volta para executar-se novamente. Quando o callback é executado, ele irá executar as funções de loop principal e chamar-se novamente em um 60 de segundo. Então, o que esse loop de retorno faz é garantir que as funções do loop principal sejam chamadas a cada 60º de segundo para nos dar uma taxa de quadros de 60 quadros por segundo.</p></li>
                <li><strong>Parâmetros: </strong><p>val - Tempo de retorno</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void runMainLoop(int val)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glMatrixMode</p></li>
                <li><strong>Descrição: </strong><p>Especifica qual é a matriz atual.</p></li>
                <li><strong>Parâmetros: </strong><p>Variável mode (Especifica qual pilha de matriz é o destino para operações de matriz subsequentes.) Valores aceitos: GL_MODELVIEW, GL_PROJECTION e GL_TEXTURE. Sendo que o valor inicial é GL_MODELVIEW.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glMatrixMode(GLenum(mode))</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glLoadIdentity</p></li>
                <li><strong>Descrição: </strong><p>Substitui a matriz atual pela matriz identidade.</p></li>
                <li><strong>Parâmetros: </strong><p>void</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glLoadIdentity(void)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glClearColor</p></li>
                <li><strong>Descrição: </strong><p>Especifica valores vermelho, verde, azul e alfa usados  para a inicialização do buffer de cores. Os valores iniciais são todos iguais a 0.</p></li>
                <li><strong>Parâmetros: </strong><p>Variáveis red, green, blue e alpha.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glClearColor(GLfloat(red), GLfloat(green), GLfloat(blue), GLfloat(alpha))</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glGetError</p></li>
                <li><strong>Descrição: </strong><p>Retorna uma intormação de erro. A cada erro detectado é atribuído um código numérico e um nome simbólico. Quando ocorre um erro, o sinalizador de erro é definido para o valor de código de erro apropriado.</p></li>
                <li><strong>Parâmetros: </strong><p>void</p></li>
                <li><strong>Retorno: </strong><p>Valor da flag de erro do tipo GLenum.</p></li>
                <li><strong>Protótipo: </strong><p>GLenum glGetError(void)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glClear</p></li>
                <li><strong>Descrição: </strong><p>Limpa os buffers para valores predefinidos por glClearDepth ou glClearStencil.</p></li>
                <li><strong>Parâmetros: </strong><p>Máscaras (tipo GLbitfield) que indicam os buffers a serem limpos. As três máscaras são: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT e GL_STENCIL_BUFFER_BIT.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glClear(GLbitfield mask)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glBegin</p></li>
                <li><strong>Descrição: </strong><p>Delimita os vértices de um tipo primitivo ou um grupo de tipos primitivos.</p></li>
                <li><strong>Parâmetros: </strong><p>Variável mode (Especifica os tipos primitivos que serão criados a partir dos vértices presentes entre o glBegin e o subsequente glEnd) Constantes aceitas: GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP e GL_POLYGON.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glBegin(GLenum(mode))</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glVertex</p></li>
                <li><strong>Descrição: </strong><p>Especifica um vértice.</p></li>
                <li><strong>Parâmetros: </strong><p>Coordenadas x,y,z e w do vértice. Nem todos os parâmetros estão presentes em todas as formas do comando.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glVertex(*args)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glutSwapBuffers</p></li>
                <li><strong>Descrição: </strong><p>Promove a troca do buffer secundário (atual) e seu conteúdo para se tornar o conteúdo do buffer de frente.</p></li>
                <li><strong>Parâmetros: </strong><p>void</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glutSwapBuffers(void)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glutTimerFunc</p></li>
                <li><strong>Descrição: </strong><p>Registra um tempo de retorno a ser acionado em um número especificado de milisegundos.</p></li>
                <li><strong>Parâmetros: </strong><p>Milissegundos tipo unsigned int, ponteiro a função do tipo void (*func)(int value) e o tempo de retorno.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glutTimerFunc(unsigned int msecs,void (*func)(int value), int value)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glutInitContextVersion</p></li>
                <li><strong>Descrição: </strong><p>Utilizada para definir a versão de contexto do OpenGL. Lembrando que esta função não faz parte do GLUT.</p></li>
                <li><strong>Parâmetros: </strong><p>Numeração da versão, por exemplo, versão x.y, definiremos como glutInitContextVersion(x,y).</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glutInitContextVersion(int num1, int num2)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glutInitDisplayMode</p></li>
                <li><strong>Descrição: </strong><p>Define um modo de display inicial.</p></li>
                <li><strong>Parâmetros: </strong><p>Variável modo (Modo de exibição). Permite as seguintes máscaras: GLUT_RGBA, GLUT_RGB, GLUT_INDEX, GLUT_SINGLE, GLUT_DOUBLE, GLUT_ACCUM, GLUT_ALPHA, GLUT_DEPTH, GLUT_STENCIL, GLUT_MULTISAMPLE, GLUT_STEREO e  GLUT_LUMINANCE.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glutInitDisplayMode(unsigned int mode)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glutInitWindowSize</p></li>
                <li><strong>Descrição: </strong><p>Define o tamanho inicial da janela.</p></li>
                <li><strong>Parâmetros: </strong><p>Variáveis inteiras largura e altura (width e height) em pixels.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glutInitWindowSize(int width, int height)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glutCreateWindow</p></li>
                <li><strong>Descrição: </strong><p>Cria uma nova janela</p></li>
                <li><strong>Parâmetros: </strong><p>Uma variável nome (ponteiro a char), que vai ser o nome da janela criada.</p></li>
                <li><strong>Retorno: </strong><p>O valor retornado é um identificador inteiro pequeno exclusivo para a janela. O intervalo de identificadores alocados começa em um. </p></li>
                <li><strong>Protótipo: </strong><p>int glutCreateWindow(char *name)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glutDisplayFunc</p></li>
                <li><strong>Descrição: </strong><p>Define um display de retorno para a janela atual.</p></li>
                <li><strong>Parâmetros: </strong><p>Uma função com retorno e parâmetro void.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glutDisplayFunc(void (*func)(void))</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glutMainLoop</p></li>
                <li><strong>Descrição: </strong><p>Faz os eventos GLUT entrarem em processo de loop.</p></li>
                <li><strong>Parâmetros: </strong><p>void</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glutMainLoop(void)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glEnd</p></li>
                <li><strong>Descrição: </strong><p>Especifica que os vértices serão enviados e renderiza as figuras.</p></li>
                <li><strong>Parâmetros: </strong><p>void</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glEnd(void)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glOrtho</p></li>
                <li><strong>Descrição: </strong><p>Multiplica a matriz atual por uma matriz ortográfica (2D) com os valores right, left, bottom, top, near e far.</p></li>
                <li><strong>Parâmetros: </strong><p>Coordenadas para os planos de corte vertical esquerdo e direito (left, right);<br>Coordenadas para os planos de corte horizontal superior e inferior (bottom, top);<br>A distância para os planos de corte de profundidade mais próximo e afastado (nearVal, farVal).</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glOrtho(GLdouble(left), GLdouble(right), GLdouble(bottom), GLdouble(top), GLdouble(nearVal), GLdouble(farVal))</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glTranslate</p></li>
                <li><strong>Descrição: </strong><p>Multiplica a matriz atual por uma matriz de translação.</p></li>
                <li><strong>Parâmetros: </strong><p>Coordenadas x, y e z do vetor de translação.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glTranslate(args)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glColor</p></li>
                <li><strong>Descrição: </strong><p>Especifica a cor atual.</p></li>
                <li><strong>Parâmetros: </strong><p>Valores red, green, blue e alpha.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>glColor(*args)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>handleKeys</p></li>
                <li><strong>Descrição: </strong><p>Essa função pega um valor ASCII de uma tecla pressionada e a posição atual do mouse. Ela simplesmente alterna a flag boleana quando a tecla é pressionada.</p></li>
                <li><strong>Parâmetros: </strong><p>Valor da tecla pressionada (key) e a coordenada x e y da posição do mouse.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void handleKeys(unsigned char key,int x,int y)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glutKeyboardFunc</p></li>
                <li><strong>Descrição: </strong><p>Especifica a tecla de retorno do teclado para a janela atual.</p></li>
                <li><strong>Parâmetros: </strong><p>A nova função de retorno do teclado.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glutKeyboardFunc(void (*func)(unsigned char key,int x, int y))</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glViewport</p></li>
                <li><strong>Descrição: </strong><p>Define um modo de exibição de janela (viewport).</p></li>
                <li><strong>Parâmetros: </strong><p>x e y: especificam o canto inferior esquerdo do retângulo da janela de visualização em pixels. Valor inicial (0,0) width e height: especificam a largura e altura da viewport.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glViewport(GLint(x), GLint(y), GLsizei(width), GLsizei(height))</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glPushMatrix</p></li>
                <li><strong>Descrição: </strong><p>Salva uma cópia da matriz atual e insere em uma pilha para esta ser utilizada mais tarde. Importante lembrar que a pilha de matrizes não é infinita. Inserindo matrizes demais na pilha o programa irá retornar um erro de GL_STACK_OVERFLOW da função glGetError().</p></li>
                <li><strong>Parâmetros: </strong><p>void</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glPushMatrix((void))</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glPopMatrix</p></li>
                <li><strong>Descrição: </strong><p>Retira a matriz padrão antiga da pilha de matrizes e mescla com a matriz atual.</p></li>
                <li><strong>Parâmetros: </strong><p>void</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glPopMatrix((void))</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glutPostRedisplay</p></li>
                <li><strong>Descrição: </strong><p>Marca que janela atual precisa ser recarregada.</p></li>
                <li><strong>Parâmetros: </strong><p>void</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glutPostRedisplay(void)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>ord</p></li>
                <li><strong>Descrição: </strong><p>Retorna o código ASCII daquele caractere.</p></li>
                <li><strong>Parâmetros: </strong><p>Um caractere qualquer(char).</p></li>
                <li><strong>Retorno: </strong><p>O código ASCII correspondente àquele caractere.</p></li>
                <li><strong>Protótipo: </strong><p>int ord(char)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glDeleteTextures</p></li>
                <li><strong>Descrição: </strong><p>Deleta uma quantidade definida de texturas.</p></li>
                <li><strong>Parâmetros: </strong><p>O número de texturas a serem deletadas e o array de texturas que serão deletadas.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glDeleteTextures(GLsizei(n), const GLuint *(textures))</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glGenTextures</p></li>
                <li><strong>Descrição: </strong><p>Gera os nomes de uma quantidade determinada de texturas.</p></li>
                <li><strong>Parâmetros: </strong><p>O número de nomes de texturas a serem gerados e o array de texturas a serem nomeadas.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glGenTextures(GLsizei(n), GLuint * (textures)) </p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glBindTexture</p></li>
                <li><strong>Descrição: </strong><p>Vincula uma textura nomeada a uma textura padrão da biblioteca.</p></li>
                <li><strong>Parâmetros: </strong><p>O destino para o qual a textura será vinculada e o nome da textura. As texturas padrão podem ser: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE ou GL_TEXTURE_2D_MULTISAMPLE_ARRAY.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glBindTexture(GLenum(target), GLuint(texture))</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glTexImage</p></li>
                <li><strong>Descrição: </strong><p>Especifica uma imagem de textura bidimensional.</p></li>
                <li><strong>Parâmetros: </strong><p>A textura padrão a ser vinculada (GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z ou GL_PROXY_TEXTURE_CUBE_MAP);<br>- O nível de detalhe;<br>- O número de componentes coloridos na textura;<br>- A altura, largura e borda da imagem;<br>- O formato dos dados de pixel (GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL);<br>- O tipo de dado dos dados de pixel (GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2 e GL_UNSIGNED_INT_2_10_10_10_REV.);<br>- Um ponteiro para os dados da imagem na memória.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glTexImageX(GLenum (target), GLint (level), GLint (internalFormat), GLsizei(width), GLsizei(height), GLint(border), GLenum (format), GLenum (type), const GLvoid *(data))</p></li>
                <li><strong>Variações da função: </strong><p>O valor X pode ser: 2D, 2Df, 2Di, 2Ds, 2Dui, 2Dus. Só havendo diferença entre os tipos de dados aceitos.</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glTexParameter</p></li>
                <li><strong>Descrição: </strong><p>Define os parâmetros da textura.</p></li>
                <li><strong>Parâmetros: </strong><p>- (target) A textura de destino que pode ser: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP;<br>- (pname) O nome simbólico de um parâmetro de textura de valor único, pode ser: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T ou GL_TEXTURE_WRAP_R;<br>- (param ou params) Um valor para pname ou um ponteiro para um array onde os valores de pneme estão guardados.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void  glTexParameterX(GLenum (target), GLenum (pname), const X_type * (params))</p></li>
                <li><strong>Variações da função: </strong><p>O valor de X_type pode ser: const GLint *, const GLuint *, GLfloat, const GLfloat *, GLint, const GLint *.<br>O valor X pode ser: Iiv, Iuiv, f, fv, i, iv. Respectivamente em relação a X_type.</p></li>                
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glEnable</p></li>
                <li><strong>Descrição: </strong><p>Habilida uma textura.</p></li>
                <li><strong>Parâmetros: </strong><p>Uma constante simbólica indicando uma capacidade GL e o índice para desabilitar.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glEnable(GLenum(cap)) ou void glEnablei(GLenum(cap), GLuint(index))</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>glPixelStore</p></li>
                <li><strong>Descrição: </strong><p>Define modos de armazenamento de pixels.</p></li>
                <li><strong>Parâmetros: </strong><p>(pname) Especifica o nome simbólico do parâmetro a ser definido, pode ser: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES ou GL_PACK_ALIGNMENT. GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES ou GL_UNPACK_ALIGNMENT.<br>(param) especifica o valor que pname está definido.</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void glPixelStoreX(GLenum(pname), X_type(param))</p></li>
                <li><strong>Variações da função: </strong><p>O valor de X pode ser: f ou i;<br>O valor de X_type pode ser: GLfloat ou GLint. Respectivamente em relação a X.</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>open</p></li>
                <li><strong>Descrição: </strong><p>Lê uma imagem de um arquivo.</p></li>
                <li><strong>Parâmetros: </strong><p>O caminho para o arquivo e o modo de carregamento (se for usado deve ser 'r').</p></li>
                <li><strong>Retorno: </strong><p>Um objeto do tipo imagem.</p></li>
                <li><strong>Protótipo: </strong><p>PIL.Image.open(file,mode='r')</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>close</p></li>
                <li><strong>Descrição: </strong><p>Retira a imagem da memória.</p></li>
                <li><strong>Parâmetros: </strong><p>void</p></li>
                <li><strong>Retorno: </strong><p>void</p></li>
                <li><strong>Protótipo: </strong><p>void Image.close(void)</p></li>
            </ul>
        </section>

        <section>
            <ul>
                <li><strong>Função: </strong><p>tobytes</p></li>
                <li><strong>Descrição: </strong><p>Retorna a imagem como um objeto de bytes.</p></li>
                <li><strong>Parâmetros: </strong><p>Qual codificador usar (O padrão é usar o codificador padrão "raw") e argumentos extras para o codificador.</p></li>
                <li><strong>Retorno: </strong><p>Um objeto de bytes.</p></li>
                <li><strong>Protótipo: </strong><p>Image.tobytes(encoder_name='raw', *args)</p></li>
            </ul>
        </section>
    </body>
    <footer>
        <p>feito por mat_almeida. <a href="#topo">Voltar ao Topo.</a></p>
    </footer>
</html>